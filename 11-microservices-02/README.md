# Домашнее задание к занятию «Микросервисы: подходы»

## Задача 1: Обеспечить разработку

Предлагаемое решение: использование GitLab Ultimate (облачная версия GitLab) в сочетании с GitLab CI/CD и Docker для реализации процессов хранения кода, непрерывной интеграции и поставки.

### Архитектура решения:

1) Хранение кода:

  * GitLab (облачный сервис) для хранения Git-репозиториев. Каждый сервис размещается в отдельном репозитории.

  * Поддержка ветвления, Code Review, Protected Branches.

2) Непрерывная интеграция и поставка (CI/CD):
   
  * GitLab CI/CD для автоматизации сборок, тестирования и деплоя.

  * Конфигурация пайплайнов через файл .gitlab-ci.yml в каждом репозитории.

3) Docker:
   
  * Сборка и использование Docker-образов для изоляции окружения.

  * Интеграция с GitLab Container Registry для хранения образов.

4) Self-hosted Runners:
   
  * Развертывание агентов сборки на собственных серверах для контроля ресурсов и окружения.

| **Требование**                          | **Реализация через GitLab CI/CD**                                                                 |
|-----------------------------------------|---------------------------------------------------------------------------------------------------|
| **Запуск сборки по событию из Git**     | Триггеры на события Git (push, merge request) через правила в `.gitlab-ci.yml`.                  |
| **Ручной запуск с параметрами**         | Jobs с типом `manual` и переменными, задаваемыми через UI перед запуском.                        |
| **Настройки для каждой сборки**         | Переменные окружения (Environment Variables), включая Protected Variables для секретов.          |
| **Шаблоны для конфигураций сборок**     | Директивы `include` и `extends` в `.gitlab-ci.yml` для переиспользования шаблонов.               |
| **Несколько конфигураций из репозитория** | Матрица сборок (`parallel:matrix`) и условные правила (`rules`) для выбора конфигураций.         |
| **Кастомные шаги при сборке**           | Описание этапов в секции `script` каждого job.                                                   |
| **Собственные Docker-образы**           | Указание образа через `image` в job (например, `image: my-registry/image:tag`).                  |
| **Self-hosted агенты сборки**           | Установка GitLab Runner на собственные серверы с тегами для управления распределением задач.     |
| **Параллельный запуск сборок/тестов**   | Ключи `parallel` (для параллельных задач) и `needs` (для управления зависимостями).              |
| **Безопасное хранение секретов**        | Protected Variables (шифрование) и интеграция с HashiCorp Vault.                                 |

### Обоснование выбора:

GitLab CI/CD:

1) Интеграция «из коробки» с Git-репозиториями, что упрощает настройку.

  * Гибкость конфигурации: поддержка шаблонов, матриц и правил.

  * Self-hosted runners для работы в приватных сетях и оптимизации затрат.

  * Поддержка Docker и Container Registry для управления образами.

2) GitLab:

  * Облачная инфраструктура с высокой доступностью.
    
  * Встроенные инструменты безопасности: Secret Detection, SAST, DAST.

3) Экономия ресурсов:

  * Параллельное выполнение job-ов сокращает время сборки.

  * Возможность использования гибридной инфраструктуры (облако + свои серверы).

## Задача 2: Логи

Предлагаемое решение: использование стека Grafana Loki + Promtail + Grafana для сбора, хранения и анализа логов в микросервисной архитектуре.

### Архитектура решения:

1) Сбор логов:

  * Promtail — агент, развертываемый на каждом хосте. Собирает логи из stdout/файлов, добавляет метки (labels) и отправляет их в Loki.

  * Минимальное воздействие на приложения: логи пишутся в stdout, Promtail их автоматически обнаруживает.

2) Хранение и обработка:

  * Loki — центральное хранилище логов, оптимизированное для работы с метками (аналогично подходам в Prometheus).

  * Гарантированная доставка: Promtail ретраит отправку при ошибках, Loki поддерживает многократную запись.

3) Поиск и визуализация:

  * Grafana — интерфейс для поиска, фильтрации и анализа логов через язык запросов LogQL.

  * Возможность сохранять поисковые запросы и делиться ссылками на них.

| **Требование**                          | **Реализация через Loki/Promtail/Grafana**                                                                 |
|-----------------------------------------|-----------------------------------------------------------------------------------------------------------|
| **Сбор логов со всех хостов**           | Promtail развертывается на каждом узле, собирает логи из stdout и файлов, добавляет метки (labels).       |
| **Минимальные требования к приложениям**| Приложения пишут логи в stdout - Promtail автоматически собирает их без модификации кода приложений.      |
| **Гарантированная доставка логов**      | Promtail ретраит отправку при сбоях, Loki поддерживает надежное хранение с возможностью повторной отправки.|
| **Поиск и фильтрация логов**            | Язык запросов LogQL в Grafana (фильтрация по меткам, тексту, временным диапазонам).                      |
| **UI с доступом для разработчиков**     | Grafana предоставляет интуитивный веб-интерфейс с настройкой RBAC для контроля доступа.                   |
| **Ссылки на сохраненные поиски**       | Возможность сохранять запросы в Grafana и делиться прямыми URL с параметрами поиска.                      |

### Обоснование выбора:

- Экономичность ресурсов:

  * Loki хранит только метаданные в индексе, а сами логи — в сжатом виде, что снижает затраты на хранение.

  * Promtail легковесный и потребляет меньше ресурсов, чем Filebeat/Fluentd.

- Интеграция с экосистемой Grafana:

  * Единый интерфейс для логов (Loki), метрик (Prometheus) и трейсинга (Tempo).

  * Возможность создавать дашборды, объединяющие метрики и логи.

- Простота развертывания:

  * Loki и Promtail поддерживаются через Helm-чарты или Docker-образы.

  * Отсутствие необходимости в дополнительных компонентах.

- Гибкость запросов:

  * LogQL позволяет выполнять сложные запросы, включая агрегации и фильтрацию по меткам.

- Безопасность:

  * Поддержка RBAC в Grafana для ограничения доступа разработчиков к определенным логам.

## Задача 3: Мониторинг

Предложите решение для обеспечения сбора и анализа состояния хостов и сервисов в микросервисной архитектуре.
Решение может состоять из одного или нескольких программных продуктов и должно описывать способы и принципы их взаимодействия.

Предлагаемое решение: использование стека Prometheus + Grafana с дополнительными экспортерами (Node Exporter, cAdvisor) для сбора и анализа метрик в микросервисной архитектуре.

### Архитектура решения:

- Сбор метрик:

  * Prometheus — система мониторинга, которая пуллит метрики с экспортеров и сервисов.

  * Node Exporter — собирает метрики хостов (CPU, RAM, HDD, Network).

  * cAdvisor — собирает метрики потребления ресурсов контейнерами (актуально для Docker/Kubernetes).

  * Кастомные экспортеры — для сервисов, предоставляющих специфичные метрики (например, Prometheus-клиенты в коде приложений).

- Хранение и обработка:

  * Prometheus TSDB — база данных временных рядов для хранения метрик.

- Визуализация и анализ:

  * Grafana — интерфейс для создания дашбордов, запросов (на языке PromQL) и агрегации данных.
 
| **Требование**                          | **Реализация через Prometheus + Grafana**                                                                 |
|-----------------------------------------|----------------------------------------------------------------------------------------------------------|
| **Сбор метрик со всех хостов**          | Node Exporter на каждом сервере + Prometheus Server для сбора (pull-модель)                              |
| **Метрики ресурсов хостов (CPU, RAM)**  | Node Exporter предоставляет: `node_cpu_seconds_total`, `node_memory_MemFree_bytes` и аналоги             |
| **Метрики ресурсов сервисов**           | cAdvisor для контейнеров (Docker/K8s): `container_cpu_usage_seconds_total`, `container_memory_usage_bytes`|
| **Специфичные метрики сервисов**        | Prometheus-клиенты в коде приложений (например, `http_requests_total`) или кастомные экспортеры           |
| **UI для запросов и агрегации**         | Grafana с поддержкой PromQL: `rate(http_requests_total[5m])`, `sum by(pod) (container_memory_usage_bytes)`|
| **Настройка панелей мониторинга**       | Drag-and-drop дашборды Grafana с графиками, таблицами, алертами и переменными (например, `$env=prod`)    |

### Обоснование выбора:

1) Prometheus:

  * Оптимизирован для микросервисов и динамических сред (автообнаружение сервисов через Kubernetes, Consul).

  * Гибкий язык запросов PromQL для агрегации и анализа.

  * Интеграция с экспортерами для любых типов метрик.

2) Grafana:

  * Поддержка визуализации метрик из Prometheus и других источников (Loki, Elasticsearch).

  * Возможность создания интерактивных дашбордов с фильтрами и переменными.

  * Шаблоны дашбордов для быстрого развертывания (например, для Kubernetes).

3) Экспортеры (Node Exporter, cAdvisor):

  * Легковесные агенты с минимальным потреблением ресурсов.

  * Не требуют модификации кода приложений (сбор данных через системные метрики).


## Задача 5: Мониторинг * (необязательная)

Исходный код для задания, compose-файл и дашборд: 

https://github.com/yagavrin/devops/tree/main/11-microservices-02/src

Дашборд:

![изображение](https://github.com/user-attachments/assets/0d345c12-bc3c-4996-988d-25e93bcc0ece)
