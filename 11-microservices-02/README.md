
# Домашнее задание к занятию «Микросервисы: принципы»

## Задача 1: API Gateway 

Предложите решение для обеспечения реализации API Gateway. Составьте сравнительную таблицу возможностей различных программных решений. На основе таблицы сделайте выбор решения.

| Характеристика                     | Kong Gateway                  | NGINX                          | Traefik               | Yandex API Gateway          |
|------------------------------------|-------------------------------|--------------------------------|-----------------------|-----------------------------|
| Маршрутизация                      | Да (декларативно + GUI)       | Да (через конфиг / API)        | Да (динамически)      | Да (конфиг yaml + GUI)      |
| Аутентификация (JWT, OAuth2 и др.) | Да (через плагины)            | Частично (через lua / Plus)    | Да (middleware)       | Да                          |
| Терминация HTTPS                   | Да                            | Да                             | Да                    | Да                          |
| Масштабируемость / Cloud Native    | Отлично (Kubernetes)          | Хорошо                         | Отлично (Kubernetes) | Отлично                     |
| Open Source                        | Да (Community Edition)        | Да (OSS версия)                | Да                    | Нет                         |
| Производительность                 | Высокая                       | Очень высокая                  | Высокая              | Высокая                     |
| Поддержка Kubernetes (Ingress)     | Да (Kong Ingress)             | Да (NGINX Ingress)             | Да (Traefik Ingress) | Частично (с Yandex ALB)     |

### Выбор решения: Kong Gateway

Обоснование:

- Гибкость маршрутизации и плагинов: Kong предоставляет богатую систему плагинов, включая проверку токенов (JWT, OAuth2), rate limiting, логирование и др.
- Поддержка терминации HTTPS: Конфигурируется легко, особенно в Kubernetes через Kong Ingress Controller.
- Расширяемость и поддержка микросервисной архитектуры: Полностью совместим с Kubernetes, легко масштабируется, поддерживает service mesh через Kuma (от Kong).
- Поддержка GUI: Наличие бесплатного и платного (Enterprise) интерфейса управления (Konga, Kong Manager).

## Задача 2: Брокер сообщений

Составьте таблицу возможностей различных брокеров сообщений. На основе таблицы сделайте обоснованный выбор решения.

| Характеристика               | Apache Kafka                     | RabbitMQ                        | NATS JetStream                 | Apache Pulsar                   | Redis Streams                  |
|------------------------------|----------------------------------|---------------------------------|--------------------------------|---------------------------------|--------------------------------|
| **Кластеризация и High Availability** | Да (встроено, ZooKeeper/KRaft) | Да (кластер + Quorum queues)    | Да (JetStream + кластер NATS)  | Да (встроено + BookKeeper)      | Да (Redis Cluster)             |
| **Хранение сообщений на диске**       | Да (log-сегменты на диске)      | Да (сообщения и очереди)        | Да (JetStream persistence)     | Да (BookKeeper сегменты)        | Да (но неэффективно при больших объёмах) |
| **Скорость работы (пропускная способность)** | Очень высокая (до 1 млн msg/s) | Высокая (десятки тыс. msg/s)    | Очень высокая (сотни тыс. msg/s) | Очень высокая (на уровне Kafka) | Средняя (в зависимости от сценария) |
| **Поддержка форматов сообщений**      | Любые (байты), Avro, JSON, Protobuf | Любые (байты), JSON, XML     | Байты, JSON, Protobuf          | Байты, Avro, JSON, Protobuf     | Простые строки / JSON          |
| **Разделение прав доступа**           | Да (ACL, SASL, TLS)             | Да (vhost + user perms)         | Да (JetStream + NKEY/Auth)     | Да (многоуровневая аутентификация, JWT) | Да (на уровне ключей/stream)   |
| **Простота эксплуатации**             | Средняя (ZooKeeper / KRaft)     | Высокая (удобный UI, CLI)       | Высокая (легко разворачивается) | Средняя (много компонентов)     | Высокая (если уже есть Redis)  |
| **Поддержка отложенной доставки / повторов** | Да (через Kafka Streams)    | Да (TTL + DLX)                  | Да (встроено)                  | Да (встроено)                 | Ограничено                     |

### Рекомендованное решение: Apache Pulsar

Обоснование:

1. Кластеризация и надёжность: В Pulsar встроенная нативная кластеризация и HA, поддержка многорегиональных репликаций без дополнительных компонентов.

2. Хранение сообщений: Использует Apache BookKeeper, что даёт гибкое и быстрое хранилище с жёсткой фиксацией сообщений на диск, гарантируя доставку.

3. Высокая скорость: Производительность на уровне Kafka, поддерживает миллионы сообщений в секунду с низкой задержкой.

4. Гибкость форматов: Поддерживает любые форматы: JSON, Avro, Protobuf, байтовые массивы. Поддерживает Schema Registry, как и Kafka.

5. Безопасность: Поддержка JWT, TLS, role-based access control, изоляция по namespace’ам и tenant’ам.

6. Простота эксплуатации: Несмотря на сложную архитектуру, есть удобные CLI, REST API, веб-интерфейс и автоматизация через Helm Charts и Terraform. Поддерживается Pulsar Functions — встраиваемая логика обработки сообщений прямо внутри брокера.

## Задача 3: API Gateway * (необязательная)

### Есть три сервиса:

**minio**
- хранит загруженные файлы в бакете images,
- S3 протокол,

**uploader**
- принимает файл, если картинка сжимает и загружает его в minio,
- POST /v1/upload,

**security**
- регистрация пользователя POST /v1/user,
- получение информации о пользователе GET /v1/user,
- логин пользователя POST /v1/token,
- проверка токена GET /v1/token/validation.

### Необходимо воспользоваться любым балансировщиком и сделать API Gateway:

**POST /v1/register**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/user.

**POST /v1/token**
1. Анонимный доступ.
2. Запрос направляется в сервис security POST /v1/token.

**GET /v1/user**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис security GET /v1/user.

**POST /v1/upload**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис uploader POST /v1/upload.

**GET /v1/user/{image}**
1. Проверка токена. Токен ожидается в заголовке Authorization. Токен проверяется через вызов сервиса security GET /v1/token/validation/.
2. Запрос направляется в сервис minio GET /images/{image}.

### Ожидаемый результат

Результатом выполнения задачи должен быть docker compose файл, запустив который можно локально выполнить следующие команды с успешным результатом.
Предполагается, что для реализации API Gateway будет написан конфиг для NGinx или другого балансировщика нагрузки, который будет запущен как сервис через docker-compose и будет обеспечивать балансировку и проверку аутентификации входящих запросов.
Авторизация
curl -X POST -H 'Content-Type: application/json' -d '{"login":"bob", "password":"qwe123"}' http://localhost/token

**Загрузка файла**

curl -X POST -H 'Authorization: Bearer eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJib2IifQ.hiMVLmssoTsy1MqbmIoviDeFPvo-nCd92d4UFiN2O2I' -H 'Content-Type: octet/stream' --data-binary @yourfilename.jpg http://localhost/upload

**Получение файла**
curl -X GET http://localhost/images/4e6df220-295e-4231-82bc-45e4b1484430.jpg

---

#### [Дополнительные материалы: как запускать, как тестировать, как проверить](https://github.com/netology-code/devkub-homeworks/tree/main/11-microservices-02-principles)

---

### Как оформить ДЗ?

Выполненное домашнее задание пришлите ссылкой на .md-файл в вашем репозитории.

---
