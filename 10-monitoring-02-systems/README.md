# Домашнее задание к занятию "13.Системы мониторинга"

1. Вас пригласили настроить мониторинг на проект. На онбординге вам рассказали, что проект представляет из себя платформу для вычислений с выдачей текстовых отчетов, которые сохраняются на диск. Взаимодействие с платформой осуществляется по протоколу http. Также вам отметили, что вычисления загружают ЦПУ. Какой минимальный набор метрик вы выведите в мониторинг и почему?

- HTTP-метрики:

  * Статус-коды (2xx, 4xx, 5xx): позволят отслеживать доступность сервиса и выявлять ошибки клиентов (4xx) или сервера (5xx).

  * Время ответа: среднее время обработки запроса поможет обнаружить задержки из-за нагрузки или ошибок в коде.

  * RPS (запросы в секунду): отражает текущую нагрузку и помогает планировать масштабирование.

- Системные метрики:

  * Загрузка CPU: поскольку вычисления нагружают процессор, важно отслеживать утилизацию ядер, чтобы избежать перегрузки и "проседаний" сервиса.
    
  * Средняя загрузка CPU (CPULA 1/5/15): чтобы отслеживать насколько система справляется с текущей нагрузкой и анализировать тренды
    
  * Использование памяти: позволит предотвратить OOM (out-of-memory) ошибок, особенно если процессы кэшируют данные.

  * Использование inode: при исчерпании доступных inodes система не сможет создавать новые файлы, даже если на диске есть свободное место, что приведёт к сбоям записи отчетов

  * Дисковое пространство: отчеты сохраняются на диск — необходимо контролировать свободное место, чтобы избежать сбоев записи.

  * Дисковые операции (IOPS, latency): если отчеты большие или их много, высокая нагрузка на диск может стать узким местом.

- Бизнес-метрики:

  * Количество успешно сгенерированных отчетов: индикатор работоспособности основной функции платформы.
---

2. Менеджер продукта посмотрев на ваши метрики сказал, что ему непонятно что такое RAM/inodes/CPUla. Также он сказал, что хочет понимать, насколько мы выполняем свои обязанности перед клиентами и какое качество обслуживания. Что вы можете ему предложить?

Необходимо определить конкретные обязательства перед клиентами и метрики для их измерения:

* SLA (Service Level Agreement):
    Например: «Сервис доступен 99.5% времени ежемесячно, отчеты генерируются в течение 10 секунд».

* SLO (Service Level Objectives):

  * 98% запросов обрабатываются быстрее 5 секунд.

  * 99.9% отчетов успешно сохраняются на диск.

  * <0.1% ошибок 5xx.

* SLI (Service Level Indicators):
    Метрики, которые напрямую отражают SLO:

  * % успешных HTTP-запросов,
  * среднее время генерации отчетов,
  * % доступного дискового пространства.
  * % свободных inodes
---
   
3. Вашей DevOps команде в этом году не выделили финансирование на построение системы сбора логов. Разработчики в свою очередь хотят видеть все ошибки, которые выдают их приложения. Какое решение вы можете предпринять в этой ситуации, чтобы разработчики получали ошибки приложения?
   * Бесплатный тариф Sentry позволяет отслеживать ошибки и отправлять уведомления. Быстро подключается с минимальной конфигурацией
   * Сбор и чтение логов через встроенные инструменты Docker/Kubernetes (`kubectl logs` или `docker logs`)
   * Самодельные скрипты, которые будут отправлять уведомление при возникновении ошибок через емейл, Slack и т.д.
---

4. Вы, как опытный SRE, сделали мониторинг, куда вывели отображения выполнения SLA=99% по http кодам ответов. Вычисляете этот параметр по следующей формуле: summ_2xx_requests/summ_all_requests. Данный параметр не поднимается выше 70%, но при этом в вашей системе нет кодов ответа 5xx и 4xx. Где у вас ошибка?

Ошибка заключается в том, что учитываются только 2xx коды ответов, но не учитываются 3xx коды (редиректы). Эти коды также могут считаться успешными, так как они указывают на то, что запрос был обработан, но требует дополнительных действий от клиента

---

5. Опишите основные плюсы и минусы pull и push систем мониторинга.

### Pull-системы мониторинга

#### Плюсы:

* Централизованное управление: Сервер сам определяет, когда и как часто опрашивать агенты, что упрощает контроль над сбором данных.
* Безопасность: Агенты не требуют открытых входящих портов, так как сервер инициирует соединение. Это снижает риски атак.

* Масштабируемость: Легче распределять нагрузку, регулируя частоту опросов и балансируя запросы между узлами.

* Простая конфигурация агентов: Агентам не нужно знать адрес сервера, достаточно быть доступными для опроса.

#### Минусы:

* Задержки в обнаружении проблем: Данные обновляются только при очередном опросе, что может замедлить реакцию на инциденты.
* Потеря данных при недоступности агента: Если агент не отвечает во время опроса, данные за этот период теряются.
* Нагрузка на сервер: При большом количестве агентов сервер может столкнуться с высокой нагрузкой из-за одновременных запросов.

### Push-системы мониторинга

#### Плюсы:

* Быстрое обнаружение проблем: Агенты отправляют данные мгновенно при изменениях, что ускоряет реакцию на события.

* Надежность при временной недоступности сервера: Агенты могут буферизовать данные и отправить их позже (если поддерживается).

* Гибкость для распределенных систем: Подходит для динамических сред (например, облака), где узлы могут часто меняться.

#### Минусы:

* Риск перегрузки сервера: Массовая отправка данных от многих агентов может привести к пиковым нагрузкам.

* Сложности с безопасностью: Сервер должен принимать входящие соединения, что требует открытых портов и повышает уязвимость.

* Управление конфигурацией агентов: Каждый агент должен знать адрес сервера, что усложняет масштабирование и изменения в инфраструктуре.
---

6. Какие из ниже перечисленных систем относятся к push модели, а какие к pull? А может есть гибридные?
   
- Prometheus: Pull, поддерживает Pushgateway для push.
- TICK: Push, Telegraf может работать в pull-режиме.
- Zabbix: Гибридная,	поддерживает и pull, и push.
- VictoriaMetrics: Гибридная, поддерживает push и pull (через Prometheus).
- Nagios: Pull, возможна push-модель через плагины.

---

7. Склонируйте себе репозиторий и запустите TICK-стэк, используя технологии docker и docker-compose.

![monitoring-02-tick](https://github.com/user-attachments/assets/31eadb34-07db-4383-8c7b-f503a8add41a)

8. Перейдите в веб-интерфейс Chronograf (http://localhost:8888) и откройте вкладку Data explorer.

![monitoring-02-chronograf](https://github.com/user-attachments/assets/a1518871-790d-44e6-a47a-c1dfde6b1a60)

9. Изучите список telegraf inputs. Добавьте в конфигурацию telegraf следующий плагин - docker:

![monitoring-02-docker](https://github.com/user-attachments/assets/b0726879-a2a2-4318-8354-aa5139b7b2e3)

### Дополнительное задание

1. а) работающий код python3-скрипта https://github.com/yagavrin/devops/blob/main/10-monitoring-02-systems/src/monitoring.py
   
   б) конфигурация cron-расписания `* * * * * /usr/bin/python3 /root/monitoring.py`

   в) пример верно сформированного 'YY-MM-DD-awesome-monitoring.log'
   
```
{"timestamp": 1742757662, "avail_memory_percent": 27.59, "available_memory_gb": 1.06, "cpu_usage_percent": 100.0, "cpu_load_1m": "0.00", "cpu_load_5m": "0.08", "cpu_load_15m": "0.09"}
{"timestamp": 1742757721, "avail_memory_percent": 27.5, "available_memory_gb": 1.05, "cpu_usage_percent": 4.81, "cpu_load_1m": "0.00", "cpu_load_5m": "0.07", "cpu_load_15m": "0.08"}
{"timestamp": 1742757781, "avail_memory_percent": 27.8, "available_memory_gb": 1.06, "cpu_usage_percent": 5.88, "cpu_load_1m": "0.08", "cpu_load_5m": "0.07", "cpu_load_15m": "0.08"}
{"timestamp": 1742757841, "avail_memory_percent": 27.47, "available_memory_gb": 1.05, "cpu_usage_percent": 4.3, "cpu_load_1m": "0.03", "cpu_load_5m": "0.05", "cpu_load_15m": "0.07"}
{"timestamp": 1742757901, "avail_memory_percent": 27.23, "available_memory_gb": 1.04, "cpu_usage_percent": 5.32, "cpu_load_1m": "0.05", "cpu_load_5m": "0.06", "cpu_load_15m": "0.07"}
{"timestamp": 1742757961, "avail_memory_percent": 23.99, "available_memory_gb": 0.92, "cpu_usage_percent": 6.95, "cpu_load_1m": "0.87", "cpu_load_5m": "0.33", "cpu_load_15m": "0.17"}
{"timestamp": 1742758021, "avail_memory_percent": 24.53, "available_memory_gb": 0.94, "cpu_usage_percent": 54.68, "cpu_load_1m": "1.95", "cpu_load_5m": "0.78", "cpu_load_15m": "0.34"}
{"timestamp": 1742758081, "avail_memory_percent": 24.81, "available_memory_gb": 0.95, "cpu_usage_percent": 6.45, "cpu_load_1m": "1.32", "cpu_load_5m": "0.80", "cpu_load_15m": "0.37"}
{"timestamp": 1742758141, "avail_memory_percent": 25.92, "available_memory_gb": 0.99, "cpu_usage_percent": 12.22, "cpu_load_1m": "1.31", "cpu_load_5m": "0.91", "cpu_load_15m": "0.43"}
```

2. В веб-интерфейсе откройте вкладку Dashboards. Попробуйте создать свой dashboard

![monitoring-02-dashboard](https://github.com/user-attachments/assets/e7e73bc5-2861-4d77-88b3-8b3f8c04312a)
